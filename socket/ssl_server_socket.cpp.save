#include <openssl/bio.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

#include "config.hpp"
#include "ssl_server_socket.hpp"

using namespace std;
using namespace adns;

void ssl_server_socket::init()
{
    m_ctx = SSL_CTX_new(SSLv23_method());

    if (m_ctx == nullptr)
    {
        THROW(ssl_socket_exception, "SSL_CTX_new failed", ssl_error_string());
    }

    SSL_CTX_set_default_passwd_cb(m_ctx, password_cb);

    if (!SSL_CTX_load_verify_locations(m_ctx, const_cast<char *>(config::ssl_root_pem_file().c_str()), nullptr))
    {
        THROW(ssl_socket_exception, "SSL_CTX_load_verify_locations failed", ssl_error_string());
    }

    if (!SSL_CTX_use_certificate_chain_file(m_ctx, config::ssl_server_pem_file().c_str()))
    {
        THROW(ssl_socket_exception, "SSL_CTX_use_certificate_chain_file failed", ssl_error_string());
    }

    if (!(SSL_CTX_use_PrivateKey_file(m_ctx, config::ssl_server_pem_file().c_str(), SSL_FILETYPE_PEM))) 
    {
        THROW(ssl_socket_exception, "SSL_CTX_use_PrivateKey_file failed", ssl_error_string());
    }

    // openssl takes a copy of the passed in DH for no reason I can discern.
    DH *dh = get_dh2236();
    if (SSL_CTX_set_tmp_dh(m_ctx, dh) == 0)
    {
        DH_free(dh); 
        THROW(ssl_socket_exception, "SSL_CTX_set_tmp_dh failed", ssl_error_string());
    }
    DH_free(dh); 

    if (SSL_CTX_set_cipher_list(m_ctx, config::ssl_cypher_list().c_str()) == 0)
    {
        THROW(ssl_socket_exception, "SSL_CTX_set_cipher_list failed");
    }

    if (SSL_CTX_set_options(m_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE | SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1) == 0)
    {
        THROW(ssl_socket_exception, "SSL_CTX_set_options failed");
    }
}

ssl_server_socket::ssl_server_socket() : ssl_socket()
{
    init();
}

ssl_server_socket::~ssl_server_socket()
{
    close();
}

shared_ptr<tcp_socket> ssl_server_socket::accept()
{
    return make_ssl_socket(tcp_socket::accept());
}

list<shared_ptr<tcp_socket>> ssl_server_socket::accept_many()
{
    list<shared_ptr<tcp_socket>> sockets;

    auto tsl = tcp_socket::accept_many();

    for (auto ts : tsl)
    {
        sockets.push_back(make_ssl_socket(ts));
    }

    return sockets;
}

DH *ssl_server_socket::get_dh2236()
{
    static unsigned char dh2236_p[] =
    {
        0x0F,0x16,0xF8,0x87,0x44,0xE5,0xC3,0x00,0xE7,0x27,0x46,0xF1,
        0x8A,0xCB,0x21,0xF8,0xA5,0xAD,0x9C,0x82,0x98,0xE1,0xDE,0x5E,
        0x5F,0x3B,0xA2,0xCF,0x6C,0x37,0xAB,0xC7,0xBF,0x62,0x2B,0x3B,
        0x8A,0x96,0xF0,0xD8,0xF7,0x53,0xF2,0x07,0xBD,0x0C,0x0F,0xD7,
        0xD8,0x7D,0xC8,0xC3,0x96,0x4D,0xF5,0x24,0x8A,0x39,0x0E,0x52,
        0xE4,0x36,0xCA,0x67,0xEF,0x0F,0xC8,0x33,0xC2,0xB3,0xDB,0x77,
        0x7C,0xEB,0x5D,0x94,0xC4,0xD6,0x16,0x09,0x31,0xDE,0x27,0x3D,
        0x87,0x59,0x51,0x0F,0x88,0x52,0x21,0x92,0x94,0x17,0x2F,0xF6,
        0x11,0x9F,0x70,0xAD,0x8D,0x9F,0xFE,0xBF,0x71,0x44,0x40,0x54,
        0x63,0xBD,0x73,0xDD,0x6A,0x8D,0x6D,0xA3,0x4D,0x69,0xCA,0xD1,
        0xDC,0x1B,0xC5,0x74,0x8D,0xC4,0x0D,0x83,0x10,0x48,0xEE,0x79,
        0x03,0x07,0xF0,0x0A,0xD1,0x4C,0x1D,0xBC,0xAE,0x57,0xCC,0x4F,
        0xBE,0x42,0x85,0xBF,0x28,0xB8,0xBC,0x17,0xE0,0xF5,0x70,0x81,
        0xC9,0x58,0xC2,0x59,0xCF,0x30,0x3D,0x24,0x4C,0x23,0xB9,0xD1,
        0xAF,0xFF,0x1D,0x6B,0x7C,0x9D,0x82,0x39,0x28,0xF1,0x64,0x05,
        0xAA,0x97,0xAC,0x33,0x85,0x00,0x4B,0x20,0x79,0x37,0xCC,0x19,
        0x76,0xF5,0xAD,0xE4,0xB6,0xFA,0xCC,0x02,0xBF,0xD4,0xA0,0x76,
        0xA5,0x2F,0x5F,0x7E,0x8D,0x66,0x09,0x89,0x55,0x03,0xFA,0xAB,
        0xBD,0xE2,0x74,0x3B,0x07,0x5B,0x1C,0x0F,0x6A,0xE1,0x4A,0xF5,
        0x37,0xF8,0x9E,0x4B,0x9A,0x98,0x92,0xF0,0xFD,0xAB,0x67,0x20,
        0x8B,0xF4,0xCC,0x5F,0x9D,0x65,0x54,0x1F,0xB6,0x98,0x1A,0xC5,
        0x79,0x82,0x1D,0xC0,0x7A,0xAC,0x15,0x47,0x93,0xE1,0x65,0xE9,
        0x6D,0x81,0x18,0x14,0x05,0x9C,0xAB,0x0A,0xA8,0xB3,0x56,0x76,
        0xD2,0xDF,0xB6,0x6B,
    };

    static unsigned char dh2236_g[] = {0x02,};

    DH *dh;

    if ((dh = DH_new()) == nullptr)
    {
        THROW(ssl_server_socket_exception, "DN_new() failed");
    }

    auto p = BN_bin2bn(dh2236_p, sizeof(dh2236_p), nullptr);
    auto g = BN_bin2bn(dh2236_g, sizeof(dh2236_g), nullptr);

    if ((p == nullptr) || (g == nullptr))
    { 
        DH_free(dh); 
        THROW(ssl_server_socket_exception, "DN_bin2bn() failed");
    }

    if (DH_set0_pqg(dh, p, nullptr, g) == 0)
    {
        THROW(ssl_server_socket_exception, "DN_set0_pqg() failed");
    }

    return dh;
}

shared_ptr<tcp_socket> ssl_server_socket::make_ssl_socket(const shared_ptr<tcp_socket> &ts)
{
    auto res = make_shared<ssl_server_socket>();

    res->m_fd = ts->get_fd();
    res->m_remote_address = ts->get_remote_address();
    ts->set_fd(-1);

    res->m_bio = BIO_new_socket(res->m_fd, BIO_NOCLOSE);
    if (res->m_bio == nullptr)
    {
        THROW(ssl_socket_exception, "BIO_new_socket failed", ssl_error_string());
    }

    res->m_ssl = SSL_new(res->m_ctx);
    if (res->m_ssl == nullptr)
    {
        THROW(ssl_socket_exception, "SSL_new failed", ssl_error_string());
    }

    SSL_set_bio(res->m_ssl, res->m_bio, res->m_bio);

    if (SSL_accept(res->m_ssl) <= 0)
    {
        THROW(ssl_accept_failed_exception, "SSL_accept failed", ssl_error_string());
    }

    if (SSL_get_verify_result(res->m_ssl) != X509_V_OK)
    {
        THROW(ssl_server_socket_exception, "can't verify client certificate");
    }

    return res;
}

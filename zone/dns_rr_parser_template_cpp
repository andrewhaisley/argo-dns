// 
// Copyright 2025 Andrew Haisley
// 
// This program is free software: you can redistribute it and/or modify it under the terms 
// of the GNU General Public License as published by the Free Software Foundation, either 
// version 3 of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
// See the GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License along with this program. 
// If not, see https://www.gnu.org/licenses/.
// 
/**
 * automatically generated by rrgen.py at %%DATE_TIME%% do not edit by hand.
 */

#include <string.h>

#include <boost/lexical_cast.hpp>

#include "types.hpp"
#include "util.hpp"
#include "dns_rr_parser.hpp"
%%INCLUDE%%

using namespace std;
using namespace adns;

dns_rr_parser::dns_rr_parser()
{
}

dns_rr_parser::~dns_rr_parser()
{
}

shared_ptr<dns_rr> dns_rr_parser::parse(const octet *raw, size_t size, size_t &offset)
{
    unsigned short i, data_length;
    size_t offset_after_rr;

    shared_ptr<dns_name> name = parse_name(raw, size, offset);

    // type
    i = parse_unsigned_short(raw, size, offset);

    // get an instance of the right class based on the rr type
    shared_ptr<dns_rr> res = instantiate(static_cast<dns_rr::type_t>(i));

    res->m_name = name;

    // class - we only support IN but need the value to handle EDNS0 which overloads it 
    // to represent UDP payload side
    res->m_class = static_cast<dns_rr::class_t>(parse_unsigned_short(raw, size, offset));

    // ttl
    res->m_ttl = parse_uint(raw, size, offset);

    // length of the RR specific data
    data_length = parse_unsigned_short(raw, size, offset);

    offset_after_rr = offset + data_length;

    // parse the rr specific data
    parse(res, data_length, raw, offset + data_length, offset);

    // if the offset now isn't what the length count says it should be, fail
    if (offset != offset_after_rr)
    {
        THROW(rr_parser_format_exception, "incorrect resource record length");
    }

    return res;
}

void dns_rr_parser::unparse(octet *raw, unordered_map<dns_name, unsigned short> &name_offsets, const dns_rr &r, size_t size, size_t &offset, bool compress)
{
    unparse_name(*(r.m_name), raw, name_offsets, size, offset, compress);
    unparse_unsigned_short(static_cast<unsigned short>(r.m_type), raw, size, offset);
    unparse_unsigned_short(static_cast<unsigned short>(r.m_class), raw, size, offset);
    unparse_uint(static_cast<uint>(r.m_ttl), raw, size, offset);

    size_t offset_before = offset;
    unparse_unsigned_short(0, raw, size, offset);
        
    // unparse the rr specific data
    unparse(r, raw, name_offsets, size, offset, compress);

    // write in the record length
    unparse_unsigned_short(offset - offset_before - 2, raw, size, offset_before);
}

shared_ptr<dns_rr> dns_rr_parser::instantiate(dns_rr::type_t t)
{
    switch (t)
    {
%%INSTANTIATE%%
    }
}

void dns_rr_parser::parse(const shared_ptr<dns_rr> &rr, unsigned short rr_length, const octet *raw, size_t size, size_t &offset)
{
    switch (rr->get_type())
    {
%%PARSE%%
    }
}

void dns_rr_parser::unparse(const dns_rr &rr, octet *raw, unordered_map<dns_name, unsigned short> &name_offsets, size_t size, size_t &offset, bool compress)
{
    switch (rr.get_type())
    {
%%UNPARSE%%
    }
}

shared_ptr<dns_rr> dns_rr_parser::from_json(json j)
{
    shared_ptr<dns_rr> res = instantiate(dns_rr::string_to_type(j["type"]));

    res->m_class = dns_rr::C_IN_e;
    res->m_ttl = int(j["ttl"]);
    res->m_name = make_shared<dns_name>(dns_name(j["name"]));

    try
    {
        res->m_id = boost::lexical_cast<uuid>(string(j["rr_id"]));
    }
    catch (json_exception &e)
    {
    }

    switch (res->get_type())
    {
%%FROM_JSON%%
    }

    return res;
}

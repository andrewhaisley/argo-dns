//
//  Copyright 2025 Andrew Haisley
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
//  associated documentation files (the “Software”), to deal in the Software without restriction, 
//  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
//  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
//  subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all copies or substantial 
//  portions of the Software.
//
//  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT 
//  NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
//  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
//  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
 
/**
 * automatically generated by rrgen.py at %%DATE_TIME%% do not edit by hand.
 */

#include <string.h>

#include <boost/lexical_cast.hpp>

#include "types.hpp"
#include "util.hpp"
#include "dns_rr_parser.hpp"
%%INCLUDE%%

using namespace std;
using namespace adns;

dns_rr_parser::dns_rr_parser()
{
}

dns_rr_parser::~dns_rr_parser()
{
}

shared_ptr<dns_rr> dns_rr_parser::parse(const octet *raw, size_t size, size_t &offset)
{
    unsigned short i, data_length;
    size_t offset_after_rr;

    shared_ptr<dns_name> name = parse_name(raw, size, offset);

    // type
    i = parse_unsigned_short(raw, size, offset);

    // get an instance of the right class based on the rr type
    shared_ptr<dns_rr> res = instantiate(static_cast<dns_rr::type_t>(i));

    res->m_name = name;

    // class - we only support IN but need the value to handle EDNS0 which overloads it 
    // to represent UDP payload side
    res->m_class = static_cast<dns_rr::class_t>(parse_unsigned_short(raw, size, offset));

    // ttl
    res->m_ttl = parse_uint(raw, size, offset);

    // length of the RR specific data
    data_length = parse_unsigned_short(raw, size, offset);

    offset_after_rr = offset + data_length;

    // parse the rr specific data
    parse(res, data_length, raw, offset + data_length, offset);

    // if the offset now isn't what the length count says it should be, fail
    if (offset != offset_after_rr)
    {
        THROW(rr_parser_format_exception, "incorrect resource record length");
    }

    return res;
}

void dns_rr_parser::unparse(octet *raw, unordered_map<dns_name, unsigned short> &name_offsets, const dns_rr &r, size_t size, size_t &offset, bool compress)
{
    unparse_name(*(r.m_name), raw, name_offsets, size, offset, compress);
    unparse_unsigned_short(static_cast<unsigned short>(r.m_type), raw, size, offset);
    unparse_unsigned_short(static_cast<unsigned short>(r.m_class), raw, size, offset);
    unparse_uint(static_cast<uint>(r.m_ttl), raw, size, offset);

    size_t offset_before = offset;
    unparse_unsigned_short(0, raw, size, offset);
        
    // unparse the rr specific data
    unparse(r, raw, name_offsets, size, offset, compress);

    // write in the record length
    unparse_unsigned_short(offset - offset_before - 2, raw, size, offset_before);
}

shared_ptr<dns_rr> dns_rr_parser::instantiate(dns_rr::type_t t)
{
    switch (t)
    {
%%INSTANTIATE%%
    }
}

void dns_rr_parser::parse(const shared_ptr<dns_rr> &rr, unsigned short rr_length, const octet *raw, size_t size, size_t &offset)
{
    switch (rr->get_type())
    {
%%PARSE%%
    }
}

void dns_rr_parser::unparse(const dns_rr &rr, octet *raw, unordered_map<dns_name, unsigned short> &name_offsets, size_t size, size_t &offset, bool compress)
{
    switch (rr.get_type())
    {
%%UNPARSE%%
    }
}

shared_ptr<dns_rr> dns_rr_parser::from_json(json j)
{
    shared_ptr<dns_rr> res = instantiate(dns_rr::string_to_type(j["type"]));

    res->m_class = dns_rr::C_IN_e;
    res->m_ttl = int(j["ttl"]);
    res->m_name = make_shared<dns_name>(dns_name(j["name"]));

    try
    {
        res->m_id = boost::lexical_cast<uuid>(string(j["rr_id"]));
    }
    catch (json_exception &e)
    {
    }

    switch (res->get_type())
    {
%%FROM_JSON%%
    }

    return res;
}

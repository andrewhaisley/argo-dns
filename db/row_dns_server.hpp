//
//  Copyright 2025 Andrew Haisley
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
//  associated documentation files (the “Software”), to deal in the Software without restriction, 
//  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
//  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
//  subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all copies or substantial 
//  portions of the Software.
//
//  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT 
//  NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
//  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
//  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
 
#pragma once

/**
 * autogenerated by dbgen.py at 12:34PM on October 23, 2025, do not hand edit
 */

#include <mutex>
#include <atomic>

#include "foreign_key.hpp"
#include "row.hpp"

namespace adns
{
    namespace db
    {
        class row_dns_server final : public row
        {
        public:
    
            /**
             * invalid instance (until each member variable is set)
             */
            row_dns_server();

            /**
             * destructor
             */
            virtual ~row_dns_server();

            /**
             * get all rows from the table
             */
            static std::vector<std::shared_ptr<row_dns_server>> get_rows(connection &conn);

            static std::shared_ptr<row_dns_server> get_by_server_id(connection &c, uuid server_id);
            static std::vector<std::shared_ptr<row_dns_server>> get_by_client_id(connection &c, uuid client_id);

            static void delete_by_server_id(connection &c, uuid server_id);
            static void delete_by_client_id(connection &c, uuid client_id);

            uint get_allowed_connection_backlog() const;
            uuid get_client_id() const;
            uint get_max_external_resolutions() const;
            uint get_max_in_message_queue_length() const;
            uint get_max_out_message_queue_length() const;
            uint get_max_queued_per_question() const;
            uint get_max_recursion_depth() const;
            uint get_min_cache_ttl() const;
            uint get_num_forwarding_threads() const;
            uint get_num_receive_threads() const;
            uint get_num_send_threads() const;
            uint get_num_tcp_recursive_slots() const;
            uint get_num_tcp_threads() const;
            uint get_num_udp_recursive_slots() const;
            uint get_num_udp_threads() const;
            uint get_recursive_timeout_ms() const;
            uuid get_server_id() const;
            uint get_tcp_max_body_wait_ms() const;
            uint get_tcp_max_len_wait_ms() const;
            uint get_udp_reply_timeout_ms() const;
            uint get_udp_retry_count() const;
            uint get_doh_client_timeout_ms() const;
            uint get_maximum_http_request_size() const;
            std::string get_doh_path() const;

            void set_allowed_connection_backlog(uint v);
            void set_client_id(uuid v);
            void set_max_external_resolutions(uint v);
            void set_max_in_message_queue_length(uint v);
            void set_max_out_message_queue_length(uint v);
            void set_max_queued_per_question(uint v);
            void set_max_recursion_depth(uint v);
            void set_min_cache_ttl(uint v);
            void set_num_forwarding_threads(uint v);
            void set_num_receive_threads(uint v);
            void set_num_send_threads(uint v);
            void set_num_tcp_recursive_slots(uint v);
            void set_num_tcp_threads(uint v);
            void set_num_udp_recursive_slots(uint v);
            void set_num_udp_threads(uint v);
            void set_recursive_timeout_ms(uint v);
            void set_server_id(uuid v);
            void set_tcp_max_body_wait_ms(uint v);
            void set_tcp_max_len_wait_ms(uint v);
            void set_udp_reply_timeout_ms(uint v);
            void set_udp_retry_count(uint v);
            void set_doh_client_timeout_ms(uint v);
            void set_maximum_http_request_size(uint v);
            void set_doh_path(std::string v);


            /**
             * name of the table in the DB
             */
            virtual std::string get_table_name() const;

            /**
             * id of the table in the DB
             */
            virtual table::table_t get_table_id() const;

            /**
             * get the primary key value
             */
            virtual uuid get_primary_key_value() const;

        protected:

            /**
             * create a blank instance ready for use
             */
            virtual row *create_instance() const;

            /**
             * dynamically set a column value
             */
            virtual void set_column_value(const column &c, int value);
            virtual void set_column_value(const column &c, bool value);
            virtual void set_column_value(const column &c, uint value);
            virtual void set_column_value(const column &c, octet value);
            virtual void set_column_value(const column &c, uuid value);
            virtual void set_column_value(const column &c, const std::string &value);
            virtual void set_column_value(const column &c, const datetime &value);
            virtual void set_column_value(const column &c, const buffer &value);

            virtual void set_column_value(const column &c, nullable<int> value);
            virtual void set_column_value(const column &c, nullable<bool> value);
            virtual void set_column_value(const column &c, nullable<uint> value);
            virtual void set_column_value(const column &c, nullable<octet> value);
            virtual void set_column_value(const column &c, nullable<uuid> value);
            virtual void set_column_value(const column &c, const nullable<std::string> &value);
            virtual void set_column_value(const column &c, const nullable<datetime> &value);
            virtual void set_column_value(const column &c, const nullable<buffer> &value);

            /**
             * dynamically get a column value
             */
            virtual int          get_int_column_value(const column &c) const;
            virtual bool         get_bool_column_value(const column &c) const;
            virtual octet        get_octet_column_value(const column &c) const;
            virtual uint         get_uint_column_value(const column &c) const;
            virtual uuid         get_uuid_column_value(const column &c) const;

            virtual const std::string  &get_string_column_value(const column &c) const;
            virtual const datetime     &get_datetime_column_value(const column &c) const;
            virtual const buffer       &get_buffer_column_value(const column &c) const;

            virtual nullable<int>          get_nullable_int_column_value(const column &c) const;
            virtual nullable<bool>         get_nullable_bool_column_value(const column &c) const;
            virtual nullable<uint>         get_nullable_uint_column_value(const column &c) const;
            virtual nullable<octet>        get_nullable_octet_column_value(const column &c) const;
            virtual nullable<uuid>         get_nullable_uuid_column_value(const column &c) const;

            const virtual nullable<std::string>  &get_nullable_string_column_value(const column &c) const;
            const virtual nullable<datetime>     &get_nullable_datetime_column_value(const column &c) const;
            const virtual nullable<buffer>       &get_nullable_buffer_column_value(const column &c) const;

            /**
             * get a list of column definitions
             */
            virtual const std::vector<column> &get_columns() const;

            /**
             * get a list of foreign key definitions
             */
            virtual const std::vector<foreign_key> &get_foreign_keys() const;

            /**
             * get the primary key column
             */
            virtual const column &get_primary_key() const;

        private:

            uint m_allowed_connection_backlog;
            uuid m_client_id;
            uint m_max_external_resolutions;
            uint m_max_in_message_queue_length;
            uint m_max_out_message_queue_length;
            uint m_max_queued_per_question;
            uint m_max_recursion_depth;
            uint m_min_cache_ttl;
            uint m_num_forwarding_threads;
            uint m_num_receive_threads;
            uint m_num_send_threads;
            uint m_num_tcp_recursive_slots;
            uint m_num_tcp_threads;
            uint m_num_udp_recursive_slots;
            uint m_num_udp_threads;
            uint m_recursive_timeout_ms;
            uuid m_server_id;
            uint m_tcp_max_body_wait_ms;
            uint m_tcp_max_len_wait_ms;
            uint m_udp_reply_timeout_ms;
            uint m_udp_retry_count;
            uint m_doh_client_timeout_ms;
            uint m_maximum_http_request_size;
            std::string m_doh_path;


            static std::atomic<bool> o_initialised;
            static std::mutex o_lock;
            static std::vector<column> o_columns;
            static std::vector<foreign_key> o_foreign_keys;
            static column o_primary_key;

            /**
             * initialise the static column list if needed
             */
            static void init_static();
        
        };
    }
}

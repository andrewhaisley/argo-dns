// 
// Copyright 2025 Andrew Haisley
// 
// This program is free software: you can redistribute it and/or modify it under the terms 
// of the GNU General Public License as published by the Free Software Foundation, either 
// version 3 of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
// See the GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License along with this program. 
// If not, see https://www.gnu.org/licenses/.
// 
/**
 * autogenerated by dbgen.py at 09:57AM on November 03, 2025, do not hand edit
 */

#include <boost/uuid/uuid_generators.hpp>

#include "row_dns_server.hpp"

using namespace adns;
using namespace db;
using namespace std;

mutex row_dns_server::o_lock;
vector<column> row_dns_server::o_columns;
atomic<bool> row_dns_server::o_initialised(false);
column row_dns_server::o_primary_key;
vector<foreign_key> row_dns_server::o_foreign_keys;

static row_dns_server instance;

static shared_ptr<row_dns_server> convert_row_type(row *r)
{
    return shared_ptr<row_dns_server>(static_cast<row_dns_server*>(r));
}

static vector<shared_ptr<row_dns_server>> convert_row_type(vector<row *> vr)
{
    vector<shared_ptr<row_dns_server>> res(vr.size());
    for (size_t i = 0; i < vr.size(); i++)
    {
        res[i] = shared_ptr<row_dns_server>(static_cast<row_dns_server*>(vr[i]));
    }
    return res;
}

    
row_dns_server::row_dns_server()
{
    m_allowed_connection_backlog = 0;
    m_max_external_resolutions = 0;
    m_max_in_message_queue_length = 0;
    m_max_out_message_queue_length = 0;
    m_max_queued_per_question = 0;
    m_max_recursion_depth = 0;
    m_min_cache_ttl = 0;
    m_num_forwarding_threads = 0;
    m_num_receive_threads = 0;
    m_num_send_threads = 0;
    m_num_tcp_recursive_slots = 0;
    m_num_tcp_threads = 0;
    m_num_udp_recursive_slots = 0;
    m_num_udp_threads = 0;
    m_recursive_timeout_ms = 0;
    m_tcp_max_body_wait_ms = 0;
    m_tcp_max_len_wait_ms = 0;
    m_udp_reply_timeout_ms = 0;
    m_udp_retry_count = 0;
    m_doh_client_timeout_ms = 0;
    m_maximum_http_request_size = 0;
    m_use_forwarding_cache = false;
    m_use_forwarding_emergency_cache = false;
    m_forward_cache_max_age_seconds = 0;
    m_forward_cache_max_entries = 0;
    m_forward_cache_garbage_collect_pct = 0;
}

row_dns_server::~row_dns_server()
{
}

vector<shared_ptr<row_dns_server>> row_dns_server::get_rows(connection &conn)
{
    return convert_row_type(instance.fetch_rows(conn));
}

string row_dns_server::get_table_name() const
{
    return "dns_server";
}

table::table_t row_dns_server::get_table_id() const
{
    return table::dns_server_e;
}

row *row_dns_server::create_instance() const
{
    return new row_dns_server();
}

void row_dns_server::set_column_value(const column &c, int value)
{
    (void)value;
    THROW(row_exception, "no columns of type int found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, bool value)
{
    switch (c.get_position())
    {
    case 25:
        m_use_forwarding_cache = value;
        break;
    case 26:
        m_use_forwarding_emergency_cache = value;
        break;
    default:
        THROW(row_exception, "no columns of type bool found at position", c.get_position());
    }
}

void row_dns_server::set_column_value(const column &c, uint value)
{
    switch (c.get_position())
    {
    case 1:
        m_allowed_connection_backlog = value;
        break;
    case 3:
        m_max_external_resolutions = value;
        break;
    case 4:
        m_max_in_message_queue_length = value;
        break;
    case 5:
        m_max_out_message_queue_length = value;
        break;
    case 6:
        m_max_queued_per_question = value;
        break;
    case 7:
        m_max_recursion_depth = value;
        break;
    case 8:
        m_min_cache_ttl = value;
        break;
    case 9:
        m_num_forwarding_threads = value;
        break;
    case 10:
        m_num_receive_threads = value;
        break;
    case 11:
        m_num_send_threads = value;
        break;
    case 12:
        m_num_tcp_recursive_slots = value;
        break;
    case 13:
        m_num_tcp_threads = value;
        break;
    case 14:
        m_num_udp_recursive_slots = value;
        break;
    case 15:
        m_num_udp_threads = value;
        break;
    case 16:
        m_recursive_timeout_ms = value;
        break;
    case 18:
        m_tcp_max_body_wait_ms = value;
        break;
    case 19:
        m_tcp_max_len_wait_ms = value;
        break;
    case 20:
        m_udp_reply_timeout_ms = value;
        break;
    case 21:
        m_udp_retry_count = value;
        break;
    case 22:
        m_doh_client_timeout_ms = value;
        break;
    case 23:
        m_maximum_http_request_size = value;
        break;
    case 27:
        m_forward_cache_max_age_seconds = value;
        break;
    case 28:
        m_forward_cache_max_entries = value;
        break;
    case 29:
        m_forward_cache_garbage_collect_pct = value;
        break;
    default:
        THROW(row_exception, "no columns of type uint found at position", c.get_position());
    }
}

void row_dns_server::set_column_value(const column &c, octet value)
{
    (void)value;
    THROW(row_exception, "no columns of type octet found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, uuid value)
{
    switch (c.get_position())
    {
    case 2:
        m_client_id = value;
        break;
    case 17:
        m_server_id = value;
        break;
    default:
        THROW(row_exception, "no columns of type uuid found at position", c.get_position());
    }
}

void row_dns_server::set_column_value(const column &c, const string &value)
{
    switch (c.get_position())
    {
    case 24:
        m_doh_path = value;
        break;
    default:
        THROW(row_exception, "no columns of type string found at position", c.get_position());
    }
}

void row_dns_server::set_column_value(const column &c, const datetime &value)
{
    (void)value;
    THROW(row_exception, "no columns of type datetime found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, const buffer &value)
{
    (void)value;
    THROW(row_exception, "no columns of type buffer found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, nullable<int> value)
{
    (void)value;
    THROW(row_exception, "no columns of type int found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, nullable<bool> value)
{
    (void)value;
    THROW(row_exception, "no columns of type bool found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, nullable<uint> value)
{
    (void)value;
    THROW(row_exception, "no columns of type uint found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, nullable<octet> value)
{
    (void)value;
    THROW(row_exception, "no columns of type octet found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, nullable<uuid> value)
{
    (void)value;
    THROW(row_exception, "no columns of type uuid found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, const nullable<string> &value)
{
    (void)value;
    THROW(row_exception, "no columns of type string found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, const nullable<datetime> &value)
{
    (void)value;
    THROW(row_exception, "no columns of type datetime found", c.get_position());
}

void row_dns_server::set_column_value(const column &c, const nullable<buffer> &value)
{
    (void)value;
    THROW(row_exception, "no columns of type buffer found", c.get_position());
}

int row_dns_server::get_int_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type int found", c.get_name(), c.get_position());
}

bool row_dns_server::get_bool_column_value(const column &c) const
{
    switch (c.get_position())
    {
    case 25:
        return m_use_forwarding_cache;
    case 26:
        return m_use_forwarding_emergency_cache;
    default:
        THROW(row_exception, "no columns of type bool found at position", c.get_name(), c.get_position());
    }
}

uint row_dns_server::get_uint_column_value(const column &c) const
{
    switch (c.get_position())
    {
    case 1:
        return m_allowed_connection_backlog;
    case 3:
        return m_max_external_resolutions;
    case 4:
        return m_max_in_message_queue_length;
    case 5:
        return m_max_out_message_queue_length;
    case 6:
        return m_max_queued_per_question;
    case 7:
        return m_max_recursion_depth;
    case 8:
        return m_min_cache_ttl;
    case 9:
        return m_num_forwarding_threads;
    case 10:
        return m_num_receive_threads;
    case 11:
        return m_num_send_threads;
    case 12:
        return m_num_tcp_recursive_slots;
    case 13:
        return m_num_tcp_threads;
    case 14:
        return m_num_udp_recursive_slots;
    case 15:
        return m_num_udp_threads;
    case 16:
        return m_recursive_timeout_ms;
    case 18:
        return m_tcp_max_body_wait_ms;
    case 19:
        return m_tcp_max_len_wait_ms;
    case 20:
        return m_udp_reply_timeout_ms;
    case 21:
        return m_udp_retry_count;
    case 22:
        return m_doh_client_timeout_ms;
    case 23:
        return m_maximum_http_request_size;
    case 27:
        return m_forward_cache_max_age_seconds;
    case 28:
        return m_forward_cache_max_entries;
    case 29:
        return m_forward_cache_garbage_collect_pct;
    default:
        THROW(row_exception, "no columns of type uint found at position", c.get_name(), c.get_position());
    }
}

octet row_dns_server::get_octet_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type octet found", c.get_name(), c.get_position());
}

uuid row_dns_server::get_uuid_column_value(const column &c) const
{
    switch (c.get_position())
    {
    case 2:
        return m_client_id;
    case 17:
        return m_server_id;
    default:
        THROW(row_exception, "no columns of type uuid found at position", c.get_name(), c.get_position());
    }
}

const string &row_dns_server::get_string_column_value(const column &c) const
{
    switch (c.get_position())
    {
    case 24:
        return m_doh_path;
    default:
        THROW(row_exception, "no columns of type string found at position", c.get_name(), c.get_position());
    }
}

const datetime &row_dns_server::get_datetime_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type datetime found", c.get_name(), c.get_position());
}

const buffer &row_dns_server::get_buffer_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type buffer found", c.get_name(), c.get_position());
}

nullable<int> row_dns_server::get_nullable_int_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type int found", c.get_name(), c.get_position());
}

nullable<bool> row_dns_server::get_nullable_bool_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type bool found", c.get_name(), c.get_position());
}

nullable<uint> row_dns_server::get_nullable_uint_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type uint found", c.get_name(), c.get_position());
}

nullable<octet> row_dns_server::get_nullable_octet_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type octet found", c.get_name(), c.get_position());
}

nullable<uuid> row_dns_server::get_nullable_uuid_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type uuid found", c.get_name(), c.get_position());
}

const nullable<string> &row_dns_server::get_nullable_string_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type string found", c.get_name(), c.get_position());
}

const nullable<datetime> &row_dns_server::get_nullable_datetime_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type datetime found", c.get_name(), c.get_position());
}

const nullable<buffer> &row_dns_server::get_nullable_buffer_column_value(const column &c) const
{
    THROW(row_exception, "no columns of type buffer found", c.get_name(), c.get_position());
}

const vector<column> &row_dns_server::get_columns() const
{
    init_static();
    return o_columns;
}

const vector<foreign_key> &row_dns_server::get_foreign_keys() const
{
    init_static();
    return o_foreign_keys;
}

const column &row_dns_server::get_primary_key() const
{
    init_static();
    return o_primary_key;
}

uuid row_dns_server::get_primary_key_value() const
{
    return get_uuid_column_value(get_primary_key());
}

void row_dns_server::init_static()
{
    if (!o_initialised)
    {
        lock_guard<mutex> guard(o_lock);
        if (!o_initialised)
        {
            o_columns.push_back(column(column::uint_e, "allowed_connection_backlog", 1, false));
            o_columns.push_back(column(column::uuid_e, "client_id", 2, false));
            o_columns.push_back(column(column::uint_e, "max_external_resolutions", 3, false));
            o_columns.push_back(column(column::uint_e, "max_in_message_queue_length", 4, false));
            o_columns.push_back(column(column::uint_e, "max_out_message_queue_length", 5, false));
            o_columns.push_back(column(column::uint_e, "max_queued_per_question", 6, false));
            o_columns.push_back(column(column::uint_e, "max_recursion_depth", 7, false));
            o_columns.push_back(column(column::uint_e, "min_cache_ttl", 8, false));
            o_columns.push_back(column(column::uint_e, "num_forwarding_threads", 9, false));
            o_columns.push_back(column(column::uint_e, "num_receive_threads", 10, false));
            o_columns.push_back(column(column::uint_e, "num_send_threads", 11, false));
            o_columns.push_back(column(column::uint_e, "num_tcp_recursive_slots", 12, false));
            o_columns.push_back(column(column::uint_e, "num_tcp_threads", 13, false));
            o_columns.push_back(column(column::uint_e, "num_udp_recursive_slots", 14, false));
            o_columns.push_back(column(column::uint_e, "num_udp_threads", 15, false));
            o_columns.push_back(column(column::uint_e, "recursive_timeout_ms", 16, false));
            o_columns.push_back(column(column::uuid_e, "server_id", 17, false));
            o_primary_key = column(column::uuid_e, "server_id", 17, false);
            o_columns.push_back(column(column::uint_e, "tcp_max_body_wait_ms", 18, false));
            o_columns.push_back(column(column::uint_e, "tcp_max_len_wait_ms", 19, false));
            o_columns.push_back(column(column::uint_e, "udp_reply_timeout_ms", 20, false));
            o_columns.push_back(column(column::uint_e, "udp_retry_count", 21, false));
            o_columns.push_back(column(column::uint_e, "doh_client_timeout_ms", 22, false));
            o_columns.push_back(column(column::uint_e, "maximum_http_request_size", 23, false));
            o_columns.push_back(column(column::string_e, "doh_path", 24, false));
            o_columns.push_back(column(column::bool_e, "use_forwarding_cache", 25, false));
            o_columns.push_back(column(column::bool_e, "use_forwarding_emergency_cache", 26, false));
            o_columns.push_back(column(column::uint_e, "forward_cache_max_age_seconds", 27, false));
            o_columns.push_back(column(column::uint_e, "forward_cache_max_entries", 28, false));
            o_columns.push_back(column(column::uint_e, "forward_cache_garbage_collect_pct", 29, false));
            
            o_initialised = true;
        }
    }
}

shared_ptr<row_dns_server> row_dns_server::get_by_server_id(connection &c, uuid server_id)
{
    init_static();
    return convert_row_type(instance.fetch_row(c, o_columns[16], server_id));
}

vector<shared_ptr<row_dns_server>> row_dns_server::get_by_client_id(connection &c, uuid client_id)
{
    init_static();
    return convert_row_type(instance.fetch_rows(c, o_columns[1], client_id));
}



void row_dns_server::delete_by_server_id(connection &c, uuid server_id)
{
    init_static();
    instance.delete_rows(c, o_columns[16], server_id);
}

void row_dns_server::delete_by_client_id(connection &c, uuid client_id)
{
    init_static();
    instance.delete_rows(c, o_columns[1], client_id);
}



uint row_dns_server::get_allowed_connection_backlog() const
{
    return m_allowed_connection_backlog;
}

uuid row_dns_server::get_client_id() const
{
    return m_client_id;
}

uint row_dns_server::get_max_external_resolutions() const
{
    return m_max_external_resolutions;
}

uint row_dns_server::get_max_in_message_queue_length() const
{
    return m_max_in_message_queue_length;
}

uint row_dns_server::get_max_out_message_queue_length() const
{
    return m_max_out_message_queue_length;
}

uint row_dns_server::get_max_queued_per_question() const
{
    return m_max_queued_per_question;
}

uint row_dns_server::get_max_recursion_depth() const
{
    return m_max_recursion_depth;
}

uint row_dns_server::get_min_cache_ttl() const
{
    return m_min_cache_ttl;
}

uint row_dns_server::get_num_forwarding_threads() const
{
    return m_num_forwarding_threads;
}

uint row_dns_server::get_num_receive_threads() const
{
    return m_num_receive_threads;
}

uint row_dns_server::get_num_send_threads() const
{
    return m_num_send_threads;
}

uint row_dns_server::get_num_tcp_recursive_slots() const
{
    return m_num_tcp_recursive_slots;
}

uint row_dns_server::get_num_tcp_threads() const
{
    return m_num_tcp_threads;
}

uint row_dns_server::get_num_udp_recursive_slots() const
{
    return m_num_udp_recursive_slots;
}

uint row_dns_server::get_num_udp_threads() const
{
    return m_num_udp_threads;
}

uint row_dns_server::get_recursive_timeout_ms() const
{
    return m_recursive_timeout_ms;
}

uuid row_dns_server::get_server_id() const
{
    return m_server_id;
}

uint row_dns_server::get_tcp_max_body_wait_ms() const
{
    return m_tcp_max_body_wait_ms;
}

uint row_dns_server::get_tcp_max_len_wait_ms() const
{
    return m_tcp_max_len_wait_ms;
}

uint row_dns_server::get_udp_reply_timeout_ms() const
{
    return m_udp_reply_timeout_ms;
}

uint row_dns_server::get_udp_retry_count() const
{
    return m_udp_retry_count;
}

uint row_dns_server::get_doh_client_timeout_ms() const
{
    return m_doh_client_timeout_ms;
}

uint row_dns_server::get_maximum_http_request_size() const
{
    return m_maximum_http_request_size;
}

string row_dns_server::get_doh_path() const
{
    return m_doh_path;
}

bool row_dns_server::get_use_forwarding_cache() const
{
    return m_use_forwarding_cache;
}

bool row_dns_server::get_use_forwarding_emergency_cache() const
{
    return m_use_forwarding_emergency_cache;
}

uint row_dns_server::get_forward_cache_max_age_seconds() const
{
    return m_forward_cache_max_age_seconds;
}

uint row_dns_server::get_forward_cache_max_entries() const
{
    return m_forward_cache_max_entries;
}

uint row_dns_server::get_forward_cache_garbage_collect_pct() const
{
    return m_forward_cache_garbage_collect_pct;
}



void row_dns_server::set_allowed_connection_backlog(uint v)
{
    m_allowed_connection_backlog = v;
}

void row_dns_server::set_client_id(uuid v)
{
    m_client_id = v;
}

void row_dns_server::set_max_external_resolutions(uint v)
{
    m_max_external_resolutions = v;
}

void row_dns_server::set_max_in_message_queue_length(uint v)
{
    m_max_in_message_queue_length = v;
}

void row_dns_server::set_max_out_message_queue_length(uint v)
{
    m_max_out_message_queue_length = v;
}

void row_dns_server::set_max_queued_per_question(uint v)
{
    m_max_queued_per_question = v;
}

void row_dns_server::set_max_recursion_depth(uint v)
{
    m_max_recursion_depth = v;
}

void row_dns_server::set_min_cache_ttl(uint v)
{
    m_min_cache_ttl = v;
}

void row_dns_server::set_num_forwarding_threads(uint v)
{
    m_num_forwarding_threads = v;
}

void row_dns_server::set_num_receive_threads(uint v)
{
    m_num_receive_threads = v;
}

void row_dns_server::set_num_send_threads(uint v)
{
    m_num_send_threads = v;
}

void row_dns_server::set_num_tcp_recursive_slots(uint v)
{
    m_num_tcp_recursive_slots = v;
}

void row_dns_server::set_num_tcp_threads(uint v)
{
    m_num_tcp_threads = v;
}

void row_dns_server::set_num_udp_recursive_slots(uint v)
{
    m_num_udp_recursive_slots = v;
}

void row_dns_server::set_num_udp_threads(uint v)
{
    m_num_udp_threads = v;
}

void row_dns_server::set_recursive_timeout_ms(uint v)
{
    m_recursive_timeout_ms = v;
}

void row_dns_server::set_server_id(uuid v)
{
    m_server_id = v;
}

void row_dns_server::set_tcp_max_body_wait_ms(uint v)
{
    m_tcp_max_body_wait_ms = v;
}

void row_dns_server::set_tcp_max_len_wait_ms(uint v)
{
    m_tcp_max_len_wait_ms = v;
}

void row_dns_server::set_udp_reply_timeout_ms(uint v)
{
    m_udp_reply_timeout_ms = v;
}

void row_dns_server::set_udp_retry_count(uint v)
{
    m_udp_retry_count = v;
}

void row_dns_server::set_doh_client_timeout_ms(uint v)
{
    m_doh_client_timeout_ms = v;
}

void row_dns_server::set_maximum_http_request_size(uint v)
{
    m_maximum_http_request_size = v;
}

void row_dns_server::set_doh_path(string v)
{
    m_doh_path = v;
}

void row_dns_server::set_use_forwarding_cache(bool v)
{
    m_use_forwarding_cache = v;
}

void row_dns_server::set_use_forwarding_emergency_cache(bool v)
{
    m_use_forwarding_emergency_cache = v;
}

void row_dns_server::set_forward_cache_max_age_seconds(uint v)
{
    m_forward_cache_max_age_seconds = v;
}

void row_dns_server::set_forward_cache_max_entries(uint v)
{
    m_forward_cache_max_entries = v;
}

void row_dns_server::set_forward_cache_garbage_collect_pct(uint v)
{
    m_forward_cache_garbage_collect_pct = v;
}


